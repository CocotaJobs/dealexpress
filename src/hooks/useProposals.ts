import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import type { Database } from '@/integrations/supabase/types';

type Proposal = Database['public']['Tables']['proposals']['Row'];
type ProposalInsert = Database['public']['Tables']['proposals']['Insert'];
type ProposalUpdate = Database['public']['Tables']['proposals']['Update'];
type ProposalItem = Database['public']['Tables']['proposal_items']['Row'];
type ProposalItemInsert = Database['public']['Tables']['proposal_items']['Insert'];

export interface ProposalWithItems extends Proposal {
  items?: ProposalItem[];
  vendor?: {
    id: string;
    name: string;
  } | null;
  total_value?: number;
}

export interface ProposalItemFormData {
  item_id: string;
  item_name: string;
  item_price: number;
  quantity: number;
  discount: number;
  subtotal: number;
  max_discount?: number;
}

export function useProposals() {
  const { toast } = useToast();
  const [proposals, setProposals] = useState<ProposalWithItems[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchProposals = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      const { data: proposalsData, error: fetchError } = await supabase
        .from('proposals')
        .select('*')
        .order('created_at', { ascending: false });

      if (fetchError) throw fetchError;

      // Fetch items and calculate total for each proposal
      const proposalsWithTotals: ProposalWithItems[] = await Promise.all(
        (proposalsData || []).map(async (proposal) => {
          const { data: items } = await supabase
            .from('proposal_items')
            .select('*')
            .eq('proposal_id', proposal.id);

          // Fetch vendor name
          const { data: vendorData } = await supabase
            .from('profiles')
            .select('id, name')
            .eq('id', proposal.created_by)
            .single();

          const total_value = (items || []).reduce((sum, item) => sum + Number(item.subtotal), 0);

          return {
            ...proposal,
            items: items || [],
            vendor: vendorData || null,
            total_value,
          };
        })
      );

      setProposals(proposalsWithTotals);
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Erro ao carregar propostas';
      setError(message);
      console.error('Error fetching proposals:', err);
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchProposals();
  }, [fetchProposals]);

  const createProposal = async (
    proposalData: Omit<ProposalInsert, 'organization_id' | 'created_by' | 'proposal_number'>,
    items: ProposalItemFormData[]
  ) => {
    try {
      // Get user's organization_id and user_id
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Usuário não autenticado');

      const { data: orgData, error: orgError } = await supabase
        .rpc('get_user_organization_id');

      if (orgError) throw orgError;

      // Create proposal (proposal_number is generated by trigger)
      const { data: proposal, error: insertError } = await supabase
        .from('proposals')
        .insert({
          ...proposalData,
          organization_id: orgData,
          created_by: user.id,
          proposal_number: 'TEMP', // Will be replaced by trigger
        })
        .select()
        .single();

      if (insertError) throw insertError;

      // Insert items
      if (items.length > 0) {
        const proposalItems: ProposalItemInsert[] = items.map((item) => ({
          proposal_id: proposal.id,
          item_id: item.item_id,
          item_name: item.item_name,
          item_price: item.item_price,
          quantity: item.quantity,
          discount: item.discount,
          subtotal: item.subtotal,
        }));

        const { error: itemsError } = await supabase
          .from('proposal_items')
          .insert(proposalItems);

        if (itemsError) throw itemsError;
      }

      toast({
        title: 'Proposta criada!',
        description: `A proposta ${proposal.proposal_number} foi criada com sucesso.`,
      });

      await fetchProposals();
      return { data: proposal, error: null };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Erro ao criar proposta';
      toast({
        title: 'Erro ao criar proposta',
        description: message,
        variant: 'destructive',
      });
      return { data: null, error: message };
    }
  };

  const updateProposal = async (
    id: string,
    proposalData: ProposalUpdate,
    items?: ProposalItemFormData[]
  ) => {
    try {
      const { data: proposal, error: updateError } = await supabase
        .from('proposals')
        .update(proposalData)
        .eq('id', id)
        .select()
        .single();

      if (updateError) throw updateError;

      // Update items if provided
      if (items) {
        // Delete existing items
        await supabase
          .from('proposal_items')
          .delete()
          .eq('proposal_id', id);

        // Insert new items
        if (items.length > 0) {
          const proposalItems: ProposalItemInsert[] = items.map((item) => ({
            proposal_id: id,
            item_id: item.item_id,
            item_name: item.item_name,
            item_price: item.item_price,
            quantity: item.quantity,
            discount: item.discount,
            subtotal: item.subtotal,
          }));

          const { error: itemsError } = await supabase
            .from('proposal_items')
            .insert(proposalItems);

          if (itemsError) throw itemsError;
        }
      }

      toast({
        title: 'Proposta atualizada!',
        description: `A proposta ${proposal.proposal_number} foi atualizada.`,
      });

      await fetchProposals();
      return { data: proposal, error: null };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Erro ao atualizar proposta';
      toast({
        title: 'Erro ao atualizar proposta',
        description: message,
        variant: 'destructive',
      });
      return { data: null, error: message };
    }
  };

  const sendProposal = async (id: string) => {
    try {
      const { data: proposal, error: updateError } = await supabase
        .from('proposals')
        .update({
          status: 'sent',
          sent_at: new Date().toISOString(),
        })
        .eq('id', id)
        .select()
        .single();

      if (updateError) throw updateError;

      toast({
        title: 'Proposta enviada!',
        description: `A proposta ${proposal.proposal_number} foi marcada como enviada.`,
      });

      await fetchProposals();
      return { data: proposal, error: null };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Erro ao enviar proposta';
      toast({
        title: 'Erro ao enviar proposta',
        description: message,
        variant: 'destructive',
      });
      return { data: null, error: message };
    }
  };

  const deleteProposal = async (id: string) => {
    try {
      // Delete items first
      await supabase
        .from('proposal_items')
        .delete()
        .eq('proposal_id', id);

      // Delete proposal
      const { error: deleteError } = await supabase
        .from('proposals')
        .delete()
        .eq('id', id);

      if (deleteError) throw deleteError;

      setProposals((prev) => prev.filter((p) => p.id !== id));
      toast({
        title: 'Proposta excluída!',
        description: 'A proposta foi excluída com sucesso.',
      });
      return { error: null };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Erro ao excluir proposta';
      toast({
        title: 'Erro ao excluir proposta',
        description: message,
        variant: 'destructive',
      });
      return { error: message };
    }
  };

  const duplicateProposal = async (id: string) => {
    try {
      const proposal = proposals.find((p) => p.id === id);
      if (!proposal) throw new Error('Proposta não encontrada');

      // Get items
      const { data: items } = await supabase
        .from('proposal_items')
        .select('*')
        .eq('proposal_id', id);

      // Create new proposal
      const result = await createProposal(
        {
          client_name: proposal.client_name,
          client_email: proposal.client_email,
          client_whatsapp: proposal.client_whatsapp,
          client_company: proposal.client_company,
          client_address: proposal.client_address,
          payment_conditions: proposal.payment_conditions,
          validity_days: proposal.validity_days,
          status: 'draft',
        },
        (items || []).map((item) => ({
          item_id: item.item_id || '',
          item_name: item.item_name,
          item_price: Number(item.item_price),
          quantity: item.quantity,
          discount: Number(item.discount),
          subtotal: Number(item.subtotal),
        }))
      );

      return result;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Erro ao duplicar proposta';
      toast({
        title: 'Erro ao duplicar proposta',
        description: message,
        variant: 'destructive',
      });
      return { data: null, error: message };
    }
  };

  return {
    proposals,
    isLoading,
    error,
    fetchProposals,
    createProposal,
    updateProposal,
    sendProposal,
    deleteProposal,
    duplicateProposal,
  };
}
